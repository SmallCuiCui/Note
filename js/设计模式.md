设计模式，模块化

### 设计模式

面向对象的代码经验的总结

##### 工厂模式*

创建一个工厂函数，函数中做一个对象创建的封装，并将创建的对象return出去

~~~
function creatObj(name,age){
    var obj = new Object();
    obj.name = name;
    obj.age = age;
    return obj;
}
~~~



##### 单例模式*

只允许存在一个实例

~~~javascript
//要求每次调用得到同一个实例，则采用闭包实现，若外层调用多次会得到多个实例，故采用立即调用函数
//同一个闭包中内层函数多次调用返回值外层的变量，得到的都是外层函数的值，属于用一个值，故而只得到一个实例

//外岑函数自调用，得到内层函数，所以getInstance就是内层函数
var getInstance = (function(){
    var date = new Date();
    function instance(){
        return date;
    }
    return instance;
})();
var a = getInstance();
var b = getInstance();
console.log(a === b);//true

~~~

##### 观察者模式

又称发布订阅者模式，经典案例：事件监听，一个元素同时监听多个同类型事件，元素对象即为发布者，每个事件处理函数为订阅者

##### 策略模式

定义一系列的算法，并将它们封装起来，调用时按不同情况调用

~~~javascript
var obj = {
    "A":function(salary){
        return salary * 4;
    },
    "B":function(salary){
        return salary * 3;
    },
    "C":function(salary){
        return salary * 2;
    }
}
var getSalary(level,salary){
    return obj[level](salary);
}
var mysalary = getSalary("A",5000);
~~~

##### 代理模式

一个对象的方法不由自己调用，通过其他对象的方法调用

##### 前端常用设计模式

* 工厂模式
* 抽象工厂模式
* 单例模式
* 适配器模式
* 组合模式
* 代理模式
* 观察者模式
* 策略模式
* MVC 模式

### 模块化

##### 概念

函数封装 ---> 对象(ooa,ood,oop，存在对象之间关键复杂) ---> 立即执行函数 --->模块化规范

模块化解决问题：html中文件的引入，存在多个引入，且文件引入先后顺序，浏览器的文件加载速度等问题

模块化：项目的架构模式，使js代码的重用性非常高，使js的执行顺序youjs代码决定，而非html文件引入顺序决定。例如：多个scrip标签不会出现，只需要引入一个js，其他js文件在引入的那个js文件内处理

##### 模块化引入方式

* AMD依赖前置：所有需要的文件都在头部引入  

  代表：require.js    <https://requirejs.org/>

  特点：前期消耗网络资源大，后期执行效率高

* CMD就近依赖，在什么地方需要就在什么地方引

  代表：sea.js已废弃

  特点：整个消耗曲线比较平缓

##### RequireJS

###### 定义模块

~~~javascript
//模块a.js文件
define(function(){
    //---返回一个对象，可不返回值
    return{}
});
~~~

###### 引入模块

~~~javascript
//在index.js中引入其他模块
//参数一为数组，包块所有需要引入的模块,不需要加js后缀名
//参数二为回调函数，函数内的参数对应接收引入模块的返回值
//先引入模块（模块代码会先执行），再执行回调函数
require(["a","b"],function(a,b){
    //回调函数内可继续引入其他需要模块
    require(["c"],function(c){});
})；

~~~

###### 配置文件

~~~
//config.js
require.config({
    baseURL:"C:/",
    paths:{
        "a":"ja/a",
        "b":"js/b"
    }
})
~~~



###### 模块化demo

~~~html
<!--data-main属性可直接引入需要文件   require.js依赖文件-->
<script src = "require.js" data-main="index.js"></script>
~~~

~~~javascript
//config.js
require.config({
    //暂时采用绝对路径  模块化demo就是为我的项目
    baseURL:"E:/练习/三月/模块化demo/",
    //配置各模块的路径，相对于baseURL的路径，并为该路径命名，之后引入模块的时候直接该路径名引入
    paths:{
        "amodal":"js/a",
        "bmodal":"js/b"
    }
})
~~~

~~~javascript
//index.js  需要由script引入的唯一js文件
require(["config"],()=>{
    require(["amodal","bmodal"],(a)=>{
        a.fn();
    })
})
~~~

~~~javascript
// a模块js/a.js
// 定义一个模块,返回了一个对象
define(function () {
  // ----
  return {
      name:"a",
      fn: function () {
      	console.log("a");
    }
  }
});
~~~

~~~javascript
//b模块 js/b.js
define(function () {
  class Basic {
    constructor () {
      this.init();
    }
    init () {
      console.log("basic");
    }
  }
  new Basic();//对象内部无需外部调用方法，可以不用返回值
})
~~~

### 项目开发

