### 闭包closure

##### 函数对象

* 函数在创建的时候会创建两个对象

  一个是函数对象本身

  另一个是作用域链对象(未调用之前只有window在作用域链对象上)

* 函数调用执行时会创建一个活动对象，放到作用域链对象上，执行结束会销毁这个活动对象

##### 闭包解决问题

全局变量：函数体外定义的变量，每个函数都能修改，会造成全局污染

局部变量：在函数体内定义的变量，只有当前函数能使用，但是不能全局重复使用

需求：既能全局使用，又不会污染全局  ---闭包实现

##### 闭包步骤

1、外层函数嵌套内层函数

2、内层函数使用外层函数的局部变量

3、把内层函数作为外层函数的返回值

~~~javascript
//可以在全局操作另一个作用域的局部变量
function fn(){
    var num = 1;
    function foo(){
        num++;
        return num;
    }
    return foo;
}
var f1 = fn();//接收内层函数
var n = f1();//得到外层函数的变量
var m = f1();
//调用f1操作的是外层函数的局部变量num，属于同一个num
console.log(n,m);//2,3

//注意f1与f2操作的num不是同一个num
var f2 = fn();
~~~

##### 闭包原理

###### 调用前

###### 调用时

###### 调用后

